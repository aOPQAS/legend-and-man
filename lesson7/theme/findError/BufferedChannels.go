// Easy tasks:

// 1️⃣ Ошибка при записи в канал с буфером
// Ошибка: Программа пытается записать больше элементов в буферизованный канал, чем его размер, что вызывает блокировку программы.

// package main

// import "fmt"

// func main() {
//     ch := make(chan int, 2)

//     ch <- 1
//     ch <- 2
//     fmt.Println(<-ch)
//     ch <- 3
//     fmt.Println(<-ch)
//     fmt.Println(<-ch)
// }

// Решение: Нужно исправить, чтобы не записывалось больше данных, чем позволяет канал.

// 2️⃣ Ошибка с закрытием канала
// Ошибка: Канал закрывается, но после этого в него пытаются записывать данные. Это приведет к панике.

// package main

// import "fmt"

// func main() {
//     ch := make(chan int, 2)

//     ch <- 1
//     ch <- 2
//     fmt.Println(<-ch)
//     ch <- 3
//     fmt.Println(<-ch)

//     close(ch)

//     for val := range ch {
//         fmt.Println(val)
//     }
// }

// Решение: Нужно избежать записи в закрытый канал.

// 3️⃣ Ошибка с чтением из канала после его закрытия
// Ошибка: Программа пытается читать из закрытого канала, что приводит к зависанию программы.

// package main

// import (
//     "fmt"
//     "sync"
// )

// func main() {
//     var wg sync.WaitGroup
//     ch := make(chan int, 2)

//     wg.Add(1)
//     go func() {
//         defer wg.Done()
//         ch <- 1
//         ch <- 2
//     }()

//     wg.Wait()

//     fmt.Println(<-ch) 
//     fmt.Println(<-ch) 
// }

// Средние задачи (Medium)

// 4️⃣ Ошибка с попыткой чтения данных из канала до его записи
// Ошибка: Главная горутина пытается читать данные из канала до того, как они будут записаны в него.

package main

import "fmt"

func main() {
    ch := make(chan int, 1)

    fmt.Println(<-ch) 

    ch <- 10
    fmt.Println(<-ch)
}

// Решение: Нужно правильно синхронизировать запись и чтение данных.

// 5️⃣ Ошибка с несколькими горутинами и буферизованным каналом
// Ошибка: Несколько горутин пытаются одновременно записывать в один канал, что вызывает гонки данных.

package main

import "fmt"

func main() {
    ch := make(chan int, 2)

    go func() {
        ch <- 1
    }()
    go func() {
        ch <- 2
    }()

    fmt.Println(<-ch)
    fmt.Println(<-ch)
}

// Решение: Нужно использовать синхронизацию для корректной записи и чтения данных.

// Сложные задачи (Hard)

// 6️⃣ Горутина не завершена до закрытия канала
// Ошибка: Канал закрывается до завершения работы всех горутин, что приводит к тому, что не все данные могут быть обработаны.

package main

import "fmt"

func worker(ch chan int) {
    for msg := range ch {
        fmt.Println(msg)
    }
}

func main() {
    ch := make(chan int, 2)

    go worker(ch)

    ch <- 1
    ch <- 2

    close(ch)
}

// Решение: Нужно подождать, чтобы все горутины завершили свою работу, прежде чем закрывать канал.


// 7️⃣ Ошибка с блокировкой из-за переполнения буфера
// Ошибка Канал с буфером переполняется, и программа блокируется на записи.

package main

import "fmt"

func main() {
    ch := make(chan int, 2)

    ch <- 1
    ch <- 2
    ch <- 3 

    fmt.Println(<-ch)
}

// Решение: Нужно избежать записи в канал, если его буфер уже заполнен.

// 8️⃣ Горутины и блокировки из-за закрытого канала
// Ошибка: Канал закрывается до того, как все горутины успевают завершить свою работу.

package main

import "fmt"

func worker(ch chan int) {
    fmt.Println(<-ch)
}

func main() {
    ch := make(chan int, 2)

    go worker(ch)
    go worker(ch)

    ch <- 1
    ch <- 2

    close(ch) 
}

// Решение: Нужно правильно синхронизировать завершение горутин и закрытие канала.

// 9️⃣ Ошибка с использованием select для канала
// Ошибка: Использование select без корректной обработки состояния канала, что приводит к зависанию программы.

package main

import "fmt"

func main() {
    ch := make(chan int, 2)

    select {
    case msg := <-ch:
        fmt.Println("Received:", msg)
    default:
        fmt.Println("No message received")
    }
}

//Решение: Нужно добавить корректную обработку случаев, когда канал пуст.